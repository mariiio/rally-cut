# Feature Specification: Video Segment Editor

**Feature Branch**: `1-video-segment-editor`
**Created**: 2025-12-29
**Status**: Draft
**Input**: Web-based video editor for reviewing volleyball videos and editing rally segments

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Load Video and Segments (Priority: P1)

A user wants to open a volleyball match video along with the JSON file containing detected rally segments (generated by RallyCut analysis) to review what the AI detected.

**Why this priority**: This is the foundation of the entire application. Without loading content, no other functionality is possible.

**Independent Test**: Can be fully tested by uploading a video file and JSON file, then verifying both are displayed correctly.

**Acceptance Scenarios**:

1. **Given** the editor is open with no content loaded, **When** user uploads a video file (.mp4, .mov, .webm), **Then** the video appears in the player and can be played
2. **Given** a video is loaded, **When** user uploads a segments JSON file, **Then** segments appear in the timeline and segment list
3. **Given** no video is loaded, **When** user uploads only a JSON file, **Then** segments load and are ready for when video is added

---

### User Story 2 - Review Segments with Video (Priority: P1)

A user wants to review each detected rally by clicking on segments to jump to that point in the video, allowing them to verify the AI's detection accuracy.

**Why this priority**: Reviewing is the primary read-only use case and validates that video/timeline synchronization works.

**Independent Test**: Can be tested by clicking segments and verifying video seeks to correct timestamp.

**Acceptance Scenarios**:

1. **Given** video and segments are loaded, **When** user clicks a segment in the list, **Then** video seeks to that segment's start time
2. **Given** video is playing, **When** playhead reaches a segment, **Then** that segment is highlighted in the timeline and list
3. **Given** video and segments are loaded, **When** user clicks on the timeline, **Then** video seeks to that timestamp

---

### User Story 3 - Trim Segment Boundaries (Priority: P2)

A user notices that a rally segment starts too early or ends too late and wants to adjust the start/end times to be more accurate.

**Why this priority**: Trimming is the most common edit operation - fine-tuning AI-detected boundaries.

**Independent Test**: Can be tested by adjusting segment start/end and verifying changes persist and export correctly.

**Acceptance Scenarios**:

1. **Given** a segment is selected, **When** user drags the segment's start edge on timeline, **Then** start_time updates and segment shrinks/grows
2. **Given** a segment is selected, **When** user drags the segment's end edge on timeline, **Then** end_time updates and segment shrinks/grows
3. **Given** a segment is selected, **When** user edits start/end times in the segment panel, **Then** timeline updates to reflect changes
4. **Given** video is at a specific time, **When** user clicks "Set Start" on a segment, **Then** segment's start_time updates to current video time

---

### User Story 4 - Add New Segment (Priority: P2)

A user notices the AI missed a rally and wants to manually add it by marking the start and end points on the timeline.

**Why this priority**: Adds content that AI missed - important for completeness but less common than trimming.

**Independent Test**: Can be tested by creating a new segment, setting its times, and verifying it appears and exports.

**Acceptance Scenarios**:

1. **Given** video is loaded, **When** user clicks "Add Segment" button, **Then** a new segment form appears
2. **Given** new segment form is open, **When** user sets start time, end time, and confirms, **Then** new segment appears in timeline and list
3. **Given** video is at a specific time, **When** user clicks "Add Segment", **Then** new segment's start_time defaults to current video time

---

### User Story 5 - Remove Segment (Priority: P2)

A user decides a detected segment is not actually a rally (false positive) and wants to remove it.

**Why this priority**: Removes false positives - important for accuracy but less common than trimming.

**Independent Test**: Can be tested by deleting a segment and verifying it disappears from timeline/list and export.

**Acceptance Scenarios**:

1. **Given** a segment exists, **When** user clicks delete button on that segment, **Then** a confirmation prompt appears
2. **Given** confirmation prompt is shown, **When** user confirms deletion, **Then** segment is removed from timeline and list
3. **Given** confirmation prompt is shown, **When** user cancels, **Then** segment remains unchanged

---

### User Story 6 - Reorder Segments (Priority: P3)

A user wants to change the order of segments (e.g., to prioritize certain rallies for a highlight reel).

**Why this priority**: Reordering is useful for highlight creation but not essential for basic editing workflow.

**Independent Test**: Can be tested by dragging segments to new positions and verifying order persists in export.

**Acceptance Scenarios**:

1. **Given** multiple segments exist, **When** user drags a segment to a new position in the list, **Then** segment order updates
2. **Given** segments have been reordered, **When** user exports JSON, **Then** exported file reflects new order

---

### User Story 7 - Export Edited JSON (Priority: P1)

A user has finished editing segments and wants to export the updated JSON file to use with the RallyCut CLI for video generation.

**Why this priority**: Without export, all edits are lost. This completes the editing workflow.

**Independent Test**: Can be tested by making edits, exporting, and verifying the downloaded JSON contains all changes in correct format.

**Acceptance Scenarios**:

1. **Given** segments have been edited, **When** user clicks "Export JSON", **Then** a JSON file downloads with all changes
2. **Given** segments have been edited, **When** user exports, **Then** JSON format matches RallyCut CLI expected format exactly
3. **Given** segments have been edited, **When** user exports, **Then** stats (kept_duration, removed_duration, etc.) are recalculated

---

### Edge Cases

- What happens when user uploads invalid JSON (wrong format, corrupted)?
  - Show error message, do not clear existing segments
- What happens when segment end_time is set before start_time?
  - Prevent invalid state, show validation error
- What happens when two segments overlap after editing?
  - Allow overlapping (user may want this for transitions)
- What happens when user tries to navigate away with unsaved changes?
  - Show confirmation dialog warning about unsaved changes
- What happens when video file is too large for browser memory?
  - Video streams from disk, should handle large files; show loading indicator
- What happens when JSON has segments outside video duration?
  - Allow loading, but visually indicate segments beyond video end

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: System MUST allow users to upload video files (.mp4, .mov, .webm) via browser file picker
- **FR-002**: System MUST allow users to upload JSON segment files matching RallyCut output format
- **FR-003**: System MUST display video in a player with play/pause controls
- **FR-004**: System MUST display segments on a visual timeline below the video
- **FR-005**: System MUST display segments in a list panel with start/end times and duration
- **FR-006**: System MUST allow seeking video by clicking on timeline
- **FR-007**: System MUST allow seeking video by clicking on segment in list
- **FR-008**: System MUST highlight current segment based on video playhead position
- **FR-009**: System MUST allow trimming segment start/end by dragging edges on timeline
- **FR-010**: System MUST allow editing segment start/end times via input fields
- **FR-011**: System MUST allow setting segment start/end to current video time
- **FR-012**: System MUST allow adding new segments with auto-generated IDs
- **FR-013**: System MUST allow deleting segments with confirmation
- **FR-014**: System MUST allow reordering segments via drag-and-drop
- **FR-015**: System MUST allow exporting edited segments as JSON file
- **FR-016**: System MUST recalculate derived fields (duration, frame numbers, stats) on export
- **FR-017**: System MUST preserve all JSON fields not directly edited (version, video metadata)
- **FR-018**: System MUST warn users before navigating away with unsaved changes

### Key Entities

- **Video**: Local file loaded via browser File API; has duration, fps, dimensions
- **Segment (Rally)**: Time range within video; has id, start_time, end_time, start_frame, end_frame, duration, type, thumbnail_time
- **SegmentFile**: Container with version, video metadata, rallies array, and stats

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: Users can load a video and JSON file and begin reviewing within 5 seconds
- **SC-002**: Users can complete a typical editing session (trim 5 segments, add 1, delete 1) in under 5 minutes
- **SC-003**: Exported JSON is 100% compatible with RallyCut CLI (can be used directly for video generation)
- **SC-004**: All segment edits are immediately reflected in both timeline and list views
- **SC-005**: Video seeking via segment click is accurate to within 0.5 seconds of segment start_time
