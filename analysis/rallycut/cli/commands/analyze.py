"""Analyze commands - action classification and highlight ranking for volleyball videos."""

from __future__ import annotations

import json
from pathlib import Path
from typing import Any

import typer
from rich.console import Console
from rich.table import Table

from rallycut.cli.utils import handle_errors

app = typer.Typer(
    name="analyze",
    help="Action classification and highlight ranking",
    no_args_is_help=True,
)

console = Console()


@app.command(name="actions")
@handle_errors
def classify_actions(
    input_json: Path = typer.Argument(
        ...,
        exists=True,
        help="Player tracking JSON file (from track-players command)",
    ),
    output: Path | None = typer.Option(
        None, "--output", "-o",
        help="Output JSON file for classified actions",
    ),
    quiet: bool = typer.Option(
        False, "--quiet", "-q",
        help="Suppress progress output",
    ),
) -> None:
    """Classify player actions from tracking data.

    Runs contact detection (trajectory inflection points) and rule-based
    action classification on ball + player tracking data.

    Requires a player tracking JSON file that includes ball positions
    (generated by track-players with --filter enabled).

    Example:
        rallycut analyze actions rally_player_track.json
        rallycut analyze actions rally_player_track.json -o actions.json
    """
    from rallycut.tracking.action_classifier import classify_rally_actions
    from rallycut.tracking.ball_tracker import BallPosition
    from rallycut.tracking.contact_detector import detect_contacts
    from rallycut.tracking.player_tracker import PlayerPosition

    # Load tracking data
    with open(input_json) as f:
        data: dict[str, Any] = json.load(f)

    # Extract ball positions
    ball_data = data.get("ballPositions", [])
    if not ball_data:
        console.print("[red]Error:[/red] No ball positions in tracking data.")
        console.print("Run track-players with --filter (default) to include ball tracking.")
        raise typer.Exit(1)

    ball_positions = [
        BallPosition(
            frame_number=bp["frameNumber"],
            x=bp["x"],
            y=bp["y"],
            confidence=bp["confidence"],
        )
        for bp in ball_data
    ]

    # Extract player positions
    player_data = data.get("positions", [])
    player_positions = [
        PlayerPosition(
            frame_number=p["frameNumber"],
            track_id=p["trackId"],
            x=p["x"],
            y=p["y"],
            width=p["width"],
            height=p["height"],
            confidence=p["confidence"],
        )
        for p in player_data
    ]

    if not quiet:
        console.print(f"[bold]Action Classification:[/bold] {input_json.name}")
        console.print(f"  Ball positions: {len(ball_positions)}")
        console.print(f"  Player positions: {len(player_positions)}")

    # Use courtSplitY from tracking data if available (more reliable than ball-based)
    court_split_y = data.get("courtSplitY")

    # Load team assignments from tracking JSON (used by both contact + action)
    team_assignments_raw = data.get("teamAssignments", {})
    team_assignments = (
        {int(k): v for k, v in team_assignments_raw.items()}
        if team_assignments_raw else None
    )

    # Step 1: Contact detection
    contact_seq = detect_contacts(
        ball_positions=ball_positions,
        player_positions=player_positions if player_positions else None,
        net_y=court_split_y,
        frame_count=data.get("frameCount"),
        team_assignments=team_assignments,
    )

    if not quiet:
        console.print(f"\n  Contacts detected: {contact_seq.num_contacts}")
        console.print(f"  Net Y estimate: {contact_seq.net_y:.3f}")

    # Step 2: Action classification
    rally_actions = classify_rally_actions(
        contact_seq, team_assignments=team_assignments,
    )

    if not quiet:
        console.print(f"  Actions classified: {len(rally_actions.actions)}")

        if rally_actions.actions:
            # Print action sequence
            seq = [a.action_type.value for a in rally_actions.actions]
            console.print(f"\n  [bold]Action sequence:[/bold] {' â†’ '.join(seq)}")

            # Print detailed table
            table = Table(title="Classified Actions")
            table.add_column("#", style="dim")
            table.add_column("Frame", justify="right")
            table.add_column("Action", style="bold")
            table.add_column("Player", justify="right")
            table.add_column("Side")
            table.add_column("Velocity", justify="right")
            table.add_column("Conf", justify="right")

            for i, action in enumerate(rally_actions.actions):
                player_str = str(action.player_track_id) if action.player_track_id >= 0 else "?"
                table.add_row(
                    str(i + 1),
                    str(action.frame),
                    action.action_type.value,
                    player_str,
                    action.court_side,
                    f"{action.velocity:.4f}",
                    f"{action.confidence:.1f}",
                )

            console.print(table)

            # Server info
            if rally_actions.serve:
                serve = rally_actions.serve
                console.print(
                    f"\n  Server: player #{serve.player_track_id} "
                    f"({serve.court_side} court)"
                )

    # Build output
    result: dict[str, Any] = {
        "contacts": contact_seq.to_dict(),
        "actions": rally_actions.to_dict(),
    }

    # Save output
    if output is None:
        output = input_json.with_name(f"{input_json.stem}_actions.json")

    with open(output, "w") as f:
        json.dump(result, f, indent=2)

    if not quiet:
        console.print(f"\n  Output: {output}")


@app.command(name="highlights")
@handle_errors
def rank_highlights(
    input_jsons: list[Path] = typer.Argument(
        ...,
        exists=True,
        help="One or more player tracking JSON files (from track-players)",
    ),
    output: Path | None = typer.Option(
        None, "--output", "-o",
        help="Output JSON file for highlight rankings",
    ),
    top_k: int = typer.Option(
        10, "--top-k", "-k",
        help="Number of top highlights to show",
    ),
    quiet: bool = typer.Option(
        False, "--quiet", "-q",
        help="Suppress progress output",
    ),
) -> None:
    """Rank rallies by excitement for highlight generation.

    Scores rallies using duration, action drama, and audio features.
    Input is one or more player tracking JSON files (each representing a rally).

    Example:
        rallycut analyze highlights rally1_track.json rally2_track.json
        rallycut analyze highlights *.json --top-k 5
    """
    from rallycut.statistics.highlights import (
        HighlightFeatures,
        HighlightScorer,
        extract_rally_features,
    )
    from rallycut.statistics.match_stats import compute_match_stats
    from rallycut.tracking.action_classifier import classify_rally_actions
    from rallycut.tracking.ball_tracker import BallPosition
    from rallycut.tracking.contact_detector import detect_contacts
    from rallycut.tracking.player_tracker import PlayerPosition

    all_features: list[HighlightFeatures] = []

    for i, json_path in enumerate(input_jsons):
        with open(json_path) as f:
            data: dict[str, Any] = json.load(f)

        rally_id = json_path.stem

        # Extract ball positions
        ball_data = data.get("ballPositions", [])
        if not ball_data:
            if not quiet:
                console.print(f"  [{i+1}] {rally_id}: no ball positions, skipping")
            continue

        ball_positions = [
            BallPosition(
                frame_number=bp["frameNumber"],
                x=bp["x"],
                y=bp["y"],
                confidence=bp["confidence"],
            )
            for bp in ball_data
        ]

        player_data = data.get("positions", [])
        player_positions = [
            PlayerPosition(
                frame_number=p["frameNumber"],
                track_id=p["trackId"],
                x=p["x"],
                y=p["y"],
                width=p["width"],
                height=p["height"],
                confidence=p["confidence"],
            )
            for p in player_data
        ]

        # Run contact detection + action classification
        court_split_y = data.get("courtSplitY")
        ta_raw = data.get("teamAssignments", {})
        ta = {int(k): v for k, v in ta_raw.items()} if ta_raw else None
        contact_seq = detect_contacts(
            ball_positions, player_positions or None, net_y=court_split_y,
            frame_count=data.get("frameCount"),
            team_assignments=ta,
        )
        rally_actions = classify_rally_actions(
            contact_seq, rally_id=rally_id, team_assignments=ta,
        )

        # Compute rally stats
        stats = compute_match_stats(
            [rally_actions], player_positions,
            video_fps=data.get("videoFps", 30.0),
        )

        rally_stat = stats.rally_stats[0] if stats.rally_stats else None

        # Extract features
        if rally_stat:
            features = extract_rally_features(rally_stat, rally_id=rally_id)
        else:
            # Minimal features from duration
            frame_count = data.get("frameCount", 0)
            fps = data.get("videoFps", 30.0)
            features = HighlightFeatures(
                rally_id=rally_id,
                duration_seconds=frame_count / fps if fps > 0 else 0.0,
                num_contacts=contact_seq.num_contacts,
            )

        all_features.append(features)

        if not quiet:
            console.print(
                f"  [{i+1}/{len(input_jsons)}] {rally_id}: "
                f"{contact_seq.num_contacts} contacts, "
                f"{features.duration_seconds:.1f}s"
            )

    if not all_features:
        console.print("[red]No rallies with ball data found.[/red]")
        raise typer.Exit(1)

    # Score and rank
    scorer = HighlightScorer()
    scores = scorer.score_rallies(all_features)
    top_scores = scorer.get_top_k(scores, k=top_k)

    if not quiet:
        console.print(f"\n[bold]Top {min(top_k, len(top_scores))} Highlights:[/bold]")

        table = Table()
        table.add_column("Rank", style="bold", justify="right")
        table.add_column("Rally")
        table.add_column("Score", justify="right")
        table.add_column("Duration", justify="right")
        table.add_column("Action", justify="right")
        table.add_column("Audio", justify="right")
        table.add_column("Context", justify="right")

        for rank, score in enumerate(top_scores, 1):
            table.add_row(
                str(rank),
                score.rally_id,
                f"{score.total_score:.3f}",
                f"{score.duration_score:.2f}",
                f"{score.action_score:.2f}",
                f"{score.audio_score:.2f}",
                f"{score.context_score:.2f}",
            )

        console.print(table)

    # Build output
    result_data: dict[str, Any] = {
        "rankings": [s.to_dict() for s in scores],
        "topK": top_k,
    }

    if output:
        with open(output, "w") as f:
            json.dump(result_data, f, indent=2)
        if not quiet:
            console.print(f"\n  Output: {output}")
